# ---------------------------------------------------------------
# Cisco VRF Route Reader
# Developed by: Brayan David Herrera Diaz
# Title: Electronics Engineer
# Contact: herreradiaz13@gmail.com
# Description: This script extracts VRF configurations from Cisco devices,
#              including VRF name, IP gateway, and route counts for OSPF, BGP, and RIP.
# ---------------------------------------------------------------

from netmiko import ConnectHandler
import pandas as pd
import re
from collections import defaultdict
import requests
import json
import time
host="cisco_devices_ip"
user="username"
password="password"
url_prtg="yoururl"
headers = {"Content-Type": "application/json"}

def conect(host,user,password):
    # Device data
    cisco_device = {
    'device_type': 'cisco_ios',
    'host': host,
    'username': user,
    'password': password,
    #    'secret': 'tu_enable_secret',
    }

    # Conexi√≥n
    net_connect = ConnectHandler(**cisco_device)
    net_connect.enable()
    return net_connect

#Extracting functions

def vrfs(archive):
    vrf = defaultdict(list)
    pattern = re.finditer(r'Routing Table:\s*([^\n]+)', archive)
    for match in pattern:
        vrf_id = match.group(1).strip()
        vrf["VRFs"].append(vrf_id)  # Agrega solo el ID, no el diccionario completo

    # Convertir a DataFrame
    vrf_df = pd.DataFrame(vrf)
    print(f"Las VRFs encontradas en la tabla de enrutamiento son:\n{vrf_df}")
    return vrf_df

def gateway_ip(text, vrf_name):
    # Captura el bloque que sigue a "Routing Table: {vrf_name}"
    pattern = re.finditer(rf'Routing Table: {(vrf_name)}\n(?:.*\n)*?Gateway of last resort is (\d+\.\d+\.\d+\.\d+) to',text)
    for match in pattern:
        gateway = match.group(1).strip()
      # Agrega solo el ID, no el diccionario completo
    if not match:
        return {
            "vrf": vrf_name,
            "gateway": "No encontrado",
            "total_routes": 0,
            "bgp_count": 0,
            "bgp_routes": []
        }


    return {
        "vrf": vrf_name,
        "gateway": gateway,
        #"total_routes": total_routes,
        #"bgp_count": bgp_count,
        #"bgp_routes": bgp_routes
    }

def total_rutas(text, vrf_name, gateway_value):
    print(f"üîç Entrando a total_rutas para VRF: {vrf_name} con gateway: {gateway_value}")

    # Buscar el bloque de rutas que sigue al gateway
    pattern = re.finditer(
        rf'Routing Table: {(vrf_name)}\n.*?Gateway of last resort is {(gateway_value)} to.*?\n(.*?)(?=\nRouting Table:|\Z)',
        text,
        re.DOTALL
    )

    for match in pattern:
        rutas_bloque = match.group(1).strip()
        print(f"üì¶ Rutas encontradas para {vrf_name}:\n{rutas_bloque}")

        # Contar rutas que comienzan con B, O o R (permitiendo variantes como B*, O IA, R>)
        b_count = len(re.findall(r'^\s*B\S*', rutas_bloque, re.MULTILINE))
        o_count = len(re.findall(r'^\s*O\S*', rutas_bloque, re.MULTILINE))
        r_count = len(re.findall(r'^\s*R\S*', rutas_bloque, re.MULTILINE))

        return {
            "O_count": o_count,
            "B_count": b_count,
            "R_count": r_count
        }

    # Si no se encontr√≥ ning√∫n bloque
    print(f"‚ö†Ô∏è No se encontr√≥ bloque de rutas para VRF '{vrf_name}' con gateway '{gateway_value}'")
    return {
        "O_count": 0,
        "B_count": 0,
        "R_count": 0
    }

#Request function(In my case I use PRTG as monitoring tool)

def to_prtg(url_prtg,OSPF,RIP,BGP):    
    # Building payload with separated channels
    payload_prtg = {
        "prtg": {
        "result": [
        {
            "channel": "OSPF",
            "value": OSPF,
            "unit": "Routes"
        },
        {
            "channel": "RIP",
            "value": RIP,
            "unit": "Routes"
        },
        {
            "channel": "BGP",
            "value": BGP,
            "unit": "Routes"
        }
                    ]
                }
            }
    try:
        requests.post(
                url_prtg,
                headers=headers,
                data=json.dumps(payload_prtg),
                timeout=10
                )
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Sending data error : {e}")

while True:
    try:
        net_connect=conect(host,user,password)
        # Obtener VRFs
        output = net_connect.send_command("show vrf")
        vrf_list = [line.split()[0] for line in output.splitlines() if line and not line.startswith(('Name', '---'))]
        print("=== VRFs Configurated ===")
        print(output)
        # Extraer nombres de VRFs
        vrf_list = []
        for line in output.splitlines():
            if line and not line.startswith(('Name', '---')):
                vrf_name = line.split()[0]
                vrf_list.append(vrf_name)

        texto = "VRF's y sus rutas:\n"

        for vrf in vrf_list:
            try:
                route_output = net_connect.send_command(f"show ip route vrf {vrf}")
                texto += f"\nRutas de VRF {vrf}\n"
                texto += route_output + "\n"
            except:
                print(f"‚ö†Ô∏è No VRF content or not created {vrf}")
        vrf=[]
        routes_vrf=[]
        text=texto
        vrf=vrfs(text)
        O_total=0
        R_total=0
        B_total=0
        for index, vlan in vrf.iterrows():
            vrf_raw = vlan["VRFs"] 
            vrf_name = vrf_raw.replace("VRFs ", "").strip() 
            print(f"\nüîç Buscando informaci√≥n para VRF: {vrf_name}")

        # Extracting gateway
            routes = gateway_ip(text, vrf_name)
            gateway = routes.get("gateway", "Not found")

            print(f"VRF: {vrf_name}")
            print(f"Gateway of last resort: {gateway}")

        # Confirming Gateway for each VRF
            if gateway == "Not found" or not gateway:
                print(f"‚ö†Ô∏è Not found Gateway for the current VRF '{vrf_name}'. Skiping route extraction.")
                continue

        # Extracting routes
            resultado = total_rutas(text, vrf_name, gateway)

            if resultado:
                O_count = resultado.get("O_count", 0)
                B_count = resultado.get("B_count", 0)
                R_count = resultado.get("R_count", 0)
                O_total= O_total + O_count
                B_total= B_total + B_count
                R_total= R_total + R_count
                print(f"OSPF Routes (O): {O_count}")
                print(f"BGP Routes (B): {B_count}")
                print(f"RIP Routes (R): {R_count}")
            else:
                print(f"‚ö†Ô∏è Not found routes '{vrf_name}' after gateway.")
        to_prtg(url_prtg,O_total,R_total,B_total)
        time.sleep(30)
    except ValueError:
        print("The program has failed")
